âœ… STAGE 1 â€” File-Level Validation (Before Parsing)
File Integrity

â˜ File type is .csv

â˜ File is not empty

â˜ File size under limit (e.g., 5MB)

â˜ File encoding is readable (UTF-8 preferred)

Structure

â˜ File has header row

â˜ At least 1 data row exists

â˜ No completely empty columns

âœ… STAGE 2 â€” Header Validation & Normalization
Header Cleanup

â˜ Trim whitespace

â˜ Convert to lowercase

â˜ Remove special characters ((INR), â‚¹, etc.)

â˜ Normalize spaces

Header Mapping

â˜ Map bank-specific headers â†’ internal standard fields

â˜ Identify:

Date column

Description column

Amount OR Debit/Credit columns

Required Columns Check

â˜ Date exists

â˜ Description exists

â˜ Amount source exists (either amount OR debit/credit)

Unknown Headers

â˜ Log unmapped headers for debugging

â˜ Ignore irrelevant columns safely

âœ… STAGE 3 â€” Row-Level Cleanup (Per Transaction)

This is the most important section.

ğŸ”¹ Date Validation & Formatting

â˜ Trim value

â˜ Parse date successfully

â˜ Handle multiple formats (DD/MM/YYYY, MM-DD-YY, etc.)

â˜ Reject invalid dates

â˜ Reject impossible dates (e.g., 32/13/2026)

â˜ Optional: Reject future dates

â˜ Convert to standard format (YYYY-MM-DD)

ğŸ”¹ Amount Cleanup

â˜ Remove currency symbols (â‚¹, $, etc.)

â˜ Remove commas (1,20,000 â†’ 120000)

â˜ Remove CR/DR suffixes

â˜ Convert to number

â˜ Reject NaN

â˜ Reject zero if business rule requires

â˜ Handle negative properly

â˜ If debit/credit split:

Debit â†’ negative

Credit â†’ positive

ğŸ”¹ Type Normalization

â˜ Standardize to: "credit" or "debit"

â˜ Derive from:

Sign of amount OR

Debit/Credit column OR

Type column

â˜ Never store mixed casing (Credit, CR, credit)

ğŸ”¹ Description Cleanup

â˜ Trim whitespace

â˜ Remove excessive spaces

â˜ Remove non-printable characters

â˜ Replace empty with "Unknown" if needed

â˜ Optional: Limit max length

ğŸ”¹ Category Handling (Optional for Phase 2)

â˜ If category exists â†’ normalize casing

â˜ If missing â†’ set null

â˜ Do NOT auto-classify yet (Phase 3)

âœ… STAGE 4 â€” Logical Validation Rules

These protect data integrity.

â˜ Date is not null

â˜ Amount is not null

â˜ Description is not null

â˜ Amount is numeric

â˜ No absurd values (e.g., 99999999999 if you want limits)

â˜ Debit and credit not both filled in same row

â˜ If both empty â†’ reject row

âœ… STAGE 5 â€” Duplicate Detection

Define duplicate rule:

Two transactions are same if:

Same user

Same date

Same amount

Same description

Checklist:

â˜ Check against existing DB records

â˜ OR enforce DB unique composite index

â˜ Skip duplicates safely

â˜ Count skipped rows

âœ… STAGE 6 â€” Error Handling Strategy

Do NOT silently fail.

You must:

â˜ Count total rows

â˜ Count valid rows

â˜ Count skipped rows

â˜ Store reason for skipped rows

â˜ Return structured response to frontend

Example reporting checklist:

â˜ Show: â€œ498 inserted, 22 skippedâ€

â˜ Allow user to re-upload safely

âœ… STAGE 7 â€” Final Data Normalization Before Insert

Every stored transaction must be:

â˜ Date â†’ YYYY-MM-DD

â˜ Amount â†’ pure number (no commas, no symbols)

â˜ Type â†’ "credit" | "debit"

â˜ Description â†’ trimmed string

â˜ Category â†’ null or clean string

NO raw CSV values should reach database.

âœ… STAGE 8 â€” Performance & Safety

â˜ Batch insert (not row-by-row)

â˜ Handle large CSV without crashing

â˜ Prevent duplicate uploads

â˜ Avoid blocking UI too long